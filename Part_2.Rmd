---
title: 'Storytelling with R'
output: html_document
---

##Get data 
In order to get the data for this tutorial, you'll need to get an API key to use the Census API service [here](http://api.census.gov/data/key_signup.html). Once you have it, assign the key to the variable *api_key*.

```{r eval=F}
api_key <- "put api key here"
```

Now that you have the API key, run the following code that is available on the Storytelling repository on Github. This will automatically pull in code that and assemble the dataset for the visualizations in this section.
```{r eval=F}
source("https://raw.githubusercontent.com/CommerceDataService/cda_storytelling_in_r/gh-pages/get_data.R")

```
```{r echo=F, message=F, warning=F}
api_key <- "d7771f8fdc9a6508ea49c78e59c79318e4f46476"
source("https://raw.githubusercontent.com/CommerceDataService/cda_storytelling_in_r/gh-pages/get_data.R")

```

##What's in the data?
Sometimes two dimensional visuals are not enough. There is a lot more to the data that can be used to contextualize latent patterns. Often times, many analysts tend to think in two-dimensions -- like scatter plots. But there's more to it.  In the dataset that you've just imported, it has the following characteristics:

```{r}
summary(data)
```

Let's say we were provided a nice clean set of data that contains the following:

- county level data with county ID and region ID
- variables: % unemployed, % in poverty, % with at least a HS degree

What can you do with that data? Well, turns out that that these quantities are related. 
```{r, echo=F}
library(threejs)
      
      unemp <- data$pct_unemp
      poverty <- data$pct_poverty
      pct_hs_grad <- data$pct_hs_grad

        data$colors <- "#011efe0"
        data$colors[data$region==2] <- "#0bff01"
        data$colors[data$region==3] <- "#fe00f6"
        data$colors[data$region==4] <- "#fdfe02"
        
        data <- data[order(data$region),]
      
      #add labels to points
      scatterplot3js(data$pct_unemp, data$pct_poverty,data$pct_hs_grad,   
                     axisLabels=c("unemployment","hs degree or above","poverty rate"),
                     col=data$colors,
                     labels=paste(data$region_name,": ",data$geography), 
                     size=0.5,
                    renderer="canvas")
```

How did we get to this?
```{r}

#Load in Threejs library      
      library(threejs)
```

We can see that there are direct relationships between unemployment, poverty and education attainment. But there isn't much detail and the graphs aren't pretty.
```{r}
        scatterplot3js(data$pct_unemp, data$pct_poverty,data$pct_hs_grad)
```

Let's stylize the plots. First let's name the axes with *axisLabels*, which accepts a vector of axis names. The order matters and is as follows: x-axis, z-axis, y-axis
```{r}
      #Note that axis Labels should follow this order= c(x, z, y)
        scatterplot3js(data$pct_unemp, data$pct_poverty,data$pct_hs_grad,   
                     axisLabels=c("unemployment","hs degree or above","poverty rate"))    
```

Now let's change the rendering engine to give more depth to the plot. We do so by changing *renderer = "canvas"*. This just tells R threejs to use a different package to render the points
```{r}
      #Depth using render
        scatterplot3js(data$pct_unemp, data$pct_poverty,data$pct_hs_grad, 
                       axisLabels=c("unemployment","hs degree or above","poverty rate"),
                       renderer="canvas")   
```

Now, let's set the color of the points, resize the points, and flip the y axis so it's ascending from the origin. To do so, we:
- set *col = "slategrey"*
- set *flip.y = FALSE*
- set *size = 0.5*

```{r}
      #Point size, color, don't flip y axis
        scatterplot3js(data$pct_unemp, data$pct_poverty,data$pct_hs_grad, 
                       axisLabels=c("unemployment","hs degree or above","poverty rate"),
                       renderer="canvas",  flip.y=FALSE, col="slategrey",
                       size=0.5)   
```

Ultimately, we want to find more patterns. By using color, we can group regions by color. We can see some regions are worse off than others. But which? Turns out there are 4 regions:

```{r}
   unique(data$region_name)     
    unique(data$region)  
```

First, let's set each region to a different color by first creating a new variable for colors *data$colors*, then assign a hexcode to each region.
```{r}
      #Set up colors by 
        data$colors <- ""
        data$colors[data$region==1] <- "#011efe0"
        data$colors[data$region==2] <- "#0bff01"
        data$colors[data$region==3] <- "#fe00f6"
        data$colors[data$region==4] <- "#fdfe02"
```

Now, let's set *col= data$colors* so that R knows which color corresponds to each of the 3000 points.
```{r}
      data <- data[order(data$region),]
      #Grouped patterns
        scatterplot3js(data$pct_unemp, data$pct_poverty,data$pct_hs_grad, 
                       axisLabels=c("unemployment","hs degree or above","poverty rate"),
                       col=data$colors,  flip.y=FALSE, 
                       renderer="canvas", 
                       size=0.5)   
```

It's a bit annoying to look at the chart without knowing which point corresponds to which county. 
Let's add labels for each point that show up upon mousing over. 
```{r}
      #add labels to points
      scatterplot3js(data$pct_unemp, data$pct_poverty,data$pct_hs_grad,   
                     axisLabels=c("unemployment","hs degree or above","poverty rate"),
                     col=data$colors,
                     labels=paste(data$region_name,": ",data$geography), 
                     size=0.5,
                    renderer="canvas")
      
```

In short, we can tell the following key insights from this graph.

###Part 2: Maps
Sometimes graphs don't get the point across. Maps, while over used, can provide some better indication of patterns. 

Based on our 3-d graphs, we could see clustering of regions's economic performance. We can see the mess of points more clearly on a map. 

```{r echo=F, warning=FALSE, message=FALSE}
      
      library(leaflet)
      library(stringr)
        
      shape_direct <- function(url, shp) {
        library(rgdal)
        temp = tempfile()
        download.file(url, temp) ##download the URL taret to the temp file
        unzip(temp,exdir=getwd()) ##unzip that file
        return(readOGR(paste(shp,".shp",sep=""),shp))
      }
      
      shp <- shape_direct(url="http://www2.census.gov/geo/tiger/GENZ2014/shp/cb_2014_us_county_20m.zip",
                          shp= "cb_2014_us_county_20m")
      
      shp@data$GEOID <- as.character(shp@data$GEOID)
      shp <- merge(shp,data,id="GEOID")
      
      
      pal <- colorQuantile("YlGn", NULL, n = 30)
      
      state_popup <- paste0("<strong>County: </strong>", 
                            shp@data$geography, 
                            "<br><strong>Poverty Rate (%): </strong>", 
                            shp@data$pct_poverty)
      
      leaflet(data = shp) %>%
        addProviderTiles("CartoDB.Positron") %>%
        setView(lng = -98.3, lat = 39.5, zoom = 4)  %>%
        addPolygons(fillColor = ~pal(pct_poverty), 
                    fillOpacity = 0.8, 
                    color = "#BDBDC3", 
                    weight = 0.1, 
                    popup = state_popup)     
        
```


###Getting started
We can use the leaflet library to bring a geographic spin to the data. To initiate a map, we only need to open the leaflet library, then run the following:
```{r}
      library(leaflet)
      leaflet()  
```

You'll see that the map is blank with a zoom control panel on the upper left. That's because the map doesn't have data in it. There are dozens on free layers we can use:

- Stamen.Toner
- CartoDB.Positron
- HikeBike.HikeBike
- CartoDB.DarkMatter

```{r}
        leaflet() %>%
        addProviderTiles("Stamen.Toner") 
```

```{r}
        leaflet() %>%
        addProviderTiles("CartoDB.Positron") 
```

Now let's center and zoom in on the contiguous US at coordinates lon = -98.3 and lat = 39.5
```{r}
        leaflet() %>%
        addProviderTiles("CartoDB.Positron") %>%
        setView(lng = -98.3, lat = 39.5, zoom = 4) 
```

We now need to download the shapefiles, which are a popular geospatial vector data format for geographic information system (GIS) software. Shapefiles allow for rendering of various types of data, including points (e.g. coordinates), polygons (e.g. county boundaries), and lines (e.g. streets, creeks). We're going to use the US County Shapefile from the US Census: [http://www2.census.gov/geo/tiger/GENZ2014/shp/cb_2014_us_county_20m.zip](http://www2.census.gov/geo/tiger/GENZ2014/shp/cb_2014_us_county_20m.zip). To download it and load it into R, we'll need to first install the *rgdal* library. We've also written a function *shape_direct* that can be run to import the shapefile and assign it to an object *shp*.

```{r}
  
      shape_direct <- function(url, shp) {
        library(rgdal)
        temp = tempfile()
        download.file(url, temp) ##download the URL taret to the temp file
        unzip(temp,exdir=getwd()) ##unzip that file
        return(readOGR(paste(shp,".shp",sep=""),shp))
      }
      
      shp <- shape_direct(url="http://www2.census.gov/geo/tiger/GENZ2014/shp/cb_2014_us_county_20m.zip",
                          shp= "cb_2014_us_county_20m")
```

With the new shapefile now imported, we can now set *data = shp*.
```{r}
        leaflet(data=shp) %>%
        addProviderTiles("CartoDB.Positron") %>%
        setView(lng = -98.3, lat = 39.5, zoom = 4) %>%
        addPolygons(fillColor = "blue", 
                    fillOpacity = 0.8, 
                    color = "white", 
                    weight = 0.5)     
```

In order to draw insight from a map, we'll need to color code county polygons. This is known as a choropleth map -- each county is color coded with respect to a certain value of a given variable like %poverty. The shapefile on its own doesn't have the socioeconomic data and we'll need to join the data to the shapefile. Let's just quickly check the data formats of the primary key *GEOID*.
```{r}
   str(shp@data$GEOID)
   str(data$GEOID)
```

Since the *shp* primary key is in a factor format and the *data* primary key is in string or character format, we'll need to conform the formats, preferrably to strings. Then, we can merge the two datasets.
```{r}
      shp@data$GEOID <- as.character(shp@data$GEOID)
      shp <- merge(shp,data,id="GEOID")
```

With the merged datasets, we'll now need to specify a color scheme. Using *colorQuantile*, we can create a create a function that will slice any continuous variable into bins and assign colors to each bin. The syntax is as follows:
```{r, eval=F}
      pal <- colorQuantile(<Color Code>, <variable>, n = <number of bins>)
```

For our example, we'll use a Yellow-Green palette, leave <variable> as NULL so that we can re-use the palette function, and set the number of bins to 30.
```{r}

      palette <- colorQuantile("YlGn", NULL, n = 30)
```

Next we will add popup text for when a user clicks on a county in a map.
```{r}
      county_popup <- paste0("<strong>County: </strong>", 
                            shp@data$geography, 
                            "<br><strong>Poverty Rate (%): </strong>", 
                            shp@data$pct_poverty)
```

Now we'll pull it all together.
```{r}
      leaflet(data = shp) %>%
        addProviderTiles("CartoDB.Positron") %>%
        setView(lng = -98.3, lat = 39.5, zoom = 4) %>%
        addPolygons(fillColor = ~palette(pct_poverty), 
                    fillOpacity = 0.8, 
                    color = "#BDBDC3", 
                    weight = 0.1, 
                    popup = county_popup)     
        
```

We can run the same graph for *pct_unemp* by swapping out *pct_poverty*

```{r}
      
       county_popup <- paste0("<strong>County: </strong>", 
                            shp@data$geography, 
                            "<br><strong>Unemp (%): </strong>", 
                            shp@data$pct_unemp)
      
      leaflet(data = shp) %>%
        addProviderTiles("CartoDB.Positron") %>%
        setView(lng = -98.3, lat = 39.5, zoom = 4) %>%
        addPolygons(fillColor = ~palette(pct_unemp), 
                    fillOpacity = 0.8, 
                    color = "#BDBDC3", 
                    weight = 0.1, 
                    popup = county_popup)     
        
```   
```